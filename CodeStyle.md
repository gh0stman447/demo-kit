## Code style

#### Общие правила:
1.	При написании кода следует руководствоваться принципами [**DRY**](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself), [**KISS**](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF)). При создании компонентов следовать принципу единой ответственности (декомпозиция функциональных элементов и логики в кастомные хуки и различные хелперы).
2.	Как название коммита, так и проиндексированные файлы должны быть связаны по смыслу. Не приветствуется внесение большого числа разнообразных по назначению изменений в нескольких файлах одним коммитом. Для апдейта и фиксов багов приветствуются флаги в названии коммита (“fix: change imports at …”/”upd: add new icon to …”).

#### Frontend-архитектура:
3.	Проект базируется на модульном принципе:
- все переиспользуемые компоненты расположены в папке ds_res в директории на уровне директории проекта. Содержит примитивные элементы (примеры: ds_res/components, ds_res/constants, ds_res/utils, ds_res/styles);
- module – изолированный фрагмент функционала приложения. Примеры модулей: MainModule (основная бизнес логика: src/MainModule/**/*), Auth(функционал авторизации), ds_res(переиспользуемые элементы), Starter(инициализирующая логика), Base(переиспользуемый код проекта: utils, components);
- ModuleName/containers. Контейнер – композиция компонентов. Контейнер включает бизнес логику и является независимой областью на странице имеет доступ к store(actions/selectors/reducers/thunks), может выполнять редиректы, обработку ошибок, загрузку и валидацию. Внутри контейнер может содержать и использовать специфичные для него константы, хелперы, компоненты;
- ModuleName/pages – композиционные слои верхнего уровня состоящие из различных контейнеров и компонентов (пример: dashboard);
- ModuleName/layout – (header + page + footer).

#### Синтаксис
4.	Правила синтаксиса описаны в конфигах **eslint** и **prettier**.
5.	На проекте настроен скрипт на pre-commit с **husky** для авто-фикс кода по правилам **eslint** после команды git commit. Если авто-фикс невозможен – коммит не будет выполнен и потребуется ручная правка файла, либо исключение файла из staged.

#### Storybook
6.	Все переиспользуемые компоненты на проекте должны сопровождаться созданием стори-буков.

#### Тесты
7.	Каждый react-компонент должен быть покрыт следующими тестами:
- snapshot-ы;
- отработка event’s;
- обработка внешних данных с помощью mock-файлов.

### GitFlow
8. В репозитории две закрытые ветки **master** и **ReleaseCandidate**, вся основная работа разработчика ведется в ветке **ReleaseCandidate**
- разработчик получая новую задачу делает новую ветку от ветки **ReleaseCandidate** называя её **tasks/{номер задачи}** например **tasks/SKIT-1** (вероятные варианты каталогов веток **tasks**, **bugs**)
- все необходимые доработки разработчик производит в ветке задачи
- после завершения работы, разработчик делает PullRequest в ветку **ReleaseCandidate**
- задачу переваодит в состояние **PullRequest**
- другие разработчики читают PullRequest и делятся мнениями обсуждают реализацию
- после того как сформирован пулл задач для наряда(релиза), закрываются все PullRequest реализующие задачи вошедшие в наряд(релиз)
- ветка **ReleaseCandidate** становится валидной сборки артефактов подлежаших тестированию
- артефакты сборки ветки **ReleaseCandidate** устанавливабтся на Дев стенд в среде заказчика и проводится тестирование всех задач наряда(релиза)
- если в ходе тестирования выявленны ошибки для их решения создаются задачи и новые ветки запущеные по процессу
- после того как наряд(релиз) протестирован, создается PullRequest ветки **ReleaseCandidate** в ветку **master**
- финальный набор артефактов ветки **master** устанавливается на Тест стенд на стороне заказчика
- после успешного проходления тестирования в тестовой среде из финального набора артефактов собирается набор артефактов и инструкций наряда(релиза) для передачи в ГВЦ
- в согласованныей момент времени ГВЦ, согласно приложенной инструкции, устанавливает наряд(релиз) в продуктивную среду